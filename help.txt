ОБЩЕЕ ОПИСАНИЕ С ЗАДАЧАМИ
-------------------------

Точка входа - main.js, где мы задаём настройки игры, в частности список сцен.
Сцена - это игровое окно/процесс. Предлагаю создать три сцены:
- главный экран (Start.js),
- сама игра (Game.js), 
- окно окончания игры (GameOver.js).

1. На главном экране предлагаю добавить следующее:
- кнопка начала игры,
- включение/выключение музыки,
- информация о разработчиках (?).
Задачи, связанные с этой сценой:
- поиск шрифта,
- вёрстка блока с меню, включая кнопки и подключение шрифта,
- поиск музыки,
- подключение музыки,
- функционал кнопки включения/выключения музыки,
- информация о разработчиках (?):
  - красиво оформить
  - красиво добавить
- переход на следующую сцену при нажатии на кнопку начала игры

2. Игра.
Игра - простое движение фигурки по экрану. Физика блоков простая, нужно просто запретить им быть прозрачными для фигурки.
Задачи, связанные с этой сценой, если принимаем условия выше:
+ описать физику блоков
+ написать алгоритм генерации карты
- вёрстка блоков (андроидов?)
+ добавление фигурки
+ описание физики фигурки
+ описание физики движения фигурки
+ добавление элементов управления для фигурки (прыжок)
- создание большой невидимой кнопки на весь экран для управления прикосновением
+ добавление движения камеры
+ добавление счётчика (считаем секунды)
- добавление условия окончания игры
  - добавление условия падения ниже края карты
  - добавление условия соприкосновения фигурки с левым краем карты
- переход на следующую сцену
- добавление логики для паузы по время клика по игровому меню
- вёрстка игрового меню
  - музыка
  - рестарт
  - выход в главное меню
- перенос логики включения/выключения музыка
- логика рестарта
- логика перехода в главное меню

3. Окончание игры
Задачи, связанные с этой сценой:
- вёрстка блока с результатами
  - кнопка рестарта
  - вывод счётчика
  - выход в главное меню
- описание логики рестарта и соединение с соответствующей кнопкой
- логика выхода в главное меню

РАБОТА С GIT
------------
По шагам.

1. Клонируем репозиторий к себе на комп (команда git clone)
2. git checkout -b *название-ветки*
   Эта команда создаст новую ветку, в которой можно будет работать отдельно от общего проекта.
   В названии ветки лучше всего использовать ту задачу, которую в ней выполняете.
3. Коммитите туда.
   Если первый раз пушите на ветку, гит выдаст ошибку с предложением использовать другую команду.
   Нужно скопировать её в терминал и выполнить.
4. Когда закончите выполнение задачи, на главной странице репозитория на GitHub будет предложение смержить вашу ветку с главной.
   Создаёте пуллреквест.
   Изучаете вывод тестов. Если что-то не так, нужно исправить.
   Когда всё так, одобряете пуллреквест.
   Дальше нужно будет написать краткое описание.
5. git pull обновляет ваш локальный репозиторий и скачивает изменения с GitHub. Применять лучше из main
6. Если, пока вы работали на своей ветке, что-то изменилось в main, то в своей ветке после пулла:
   git merge main - скачает изменения из главной ветки в вашу

НАВИГАЦИЯ ПО SRC
----------------
main.js - главный файл. В нём содержатся настройки игры и он эту игру запускает.
scene - папка со сценами.
  game.js - сцена игры.
lib - доп. библиотека. Сюда можно добавить вспомогательные функции, используемые неоднократно в игре.
  phaser.js - из этого файла мы импортируем фейзер во все остальные.
(опционально) game - папка, которую можно создать и поместить в неё созданные подклассы для игровых объектов.

ПАМЯТКА ПО ИСПОЛЬЗУЕМОМУ ФУНКЦИОНАЛУ
------------------------------------
Вся игра состоит из сцен - игровых фреймов. У сцены есть три обязательных метода: preload, create, update. Они описаны ниже.
Объявление сцены:
export default class *название-класса* extends Phaser.Scene {
  constructor() {
    // задаём сцене название
    super('название-сцены')
  }

  // вот в это пространство можно поместить свойства сцены, занятые какими-либо игровыми объектами
  // игровые объекты можно записывать в свойства для удобства, но это не обязательно
  игровойОбъект,

  // сюда добавляется то, что нужно предзагрузить для создания сцены
  preload() {
    // здесь мы всё загружаем, поэтому load
    this.игровойОбъект.load.image('рабочее-название-изображения', 'абсолютный/путь/до/изображения');

  }

  // здесь описывается логика создания сцены: что где должно находиться и как оно должно себя вести
  // всё это выполнится ровно один раз при создании сцены
  create() {}

  // то, что находится здесь, будет выполняться при каждом обновлении фрейма
  update() {
    // ко всему, чем мы пользуемся внутри сцены, мы можем обращаться через this
    this.необязательныйМетод();
  }

  // сюда можно поместить необязательные методы, которые мы добавляем для удобства
  необязательныйМетод() {
    alert('frankly, ive never watched Evangelion');
  }
}
Соответственно, если мы хотим что-то сделать с чем-то внутри сцены, мы можем сделать это так:
this.что-то.сделайМетодКоторыйЯСоздал();
или так:
this.что-то.setScale(0.7); (из стандартной библиотеки)

НАВИГАЦИЯ ПО ДОКАМ ФЕЙЗЕРА
--------------------------
Namespaces - страница, на которую лучше не заглядывать.
Class - содержит описания ВСЕХ игровых классов. Если что, фейзер - это один огромный объект, который содержит
огромное количество настроек и подклассов. Что нам точно понадобится:
  Phaser.Cameras - управление движением камеры. В основном всё движение осуществляется за счёт него.
  Если мы хотим что-то с ним сделать, можно будет обращаться к нему как-то так: Phaser.cameras.main.вашМетод();
  Phaser.GameObjects - класс, отвечающий за игровые объекты, содержит очень много подклассов.
    Phaser.GameObjects.GameObject - самый-самый базовый подкласс игрового объекта. Можно настроить самостоятельно.
    Phaser.GameObjects.DOMElement - создаёт и управляет элементом DOM. По дефолту будут под канвасом, что можно
    изменить в main.
    Phaser.GameObjects.Graphics - рисует элемент как svg.
    Phaser.GameObjects.Group - группа объектов.
    Phaser.GameObjects.Image - неанимируемое неизменяемое изображение.
    Phaser.GameObjects.Sprite - анимируемое изменяемое изображение.
    Phaser.GameObjects.Text - текст.
  Phaser.Input - управление элементами управления.
  Phaser.Physics - физика и физическое взаимодействие объектов.
    Phaser.Physics.Matter - как я поняла, это для текстур.
    Phaser.Physics.Arcade - вроде бы используем вот это. Содержит очень много всего крутого, выделю вот это:
      Phaser.Physics.staticGroup - создаёт группу статических элементов, на которые не действует графитация.
  Phaser.Scene - управление сценой. Именно его мы расширяем в каждом файле сцен.
  Phaser.Sound - звук.
Events - события игры, которые можно прослушивать.
Остальное частично есть выше.
*Ваши дополнения и исправления*

Если ваш игровой объект принадлежит какому-то из классов, можно использовать на нём все методы надклассов 
напрямую по прототипированию. Если возникает коллизия, когда какие-то из надклассов содержат одинаковые методы, нужно обращаться
по полному пути через точки.
